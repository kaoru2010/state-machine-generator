#include <iostream>
#include <string>
#include "smc_compiler.h"
#include "gen.h"

using namespace std;

static void generate_state_map(state_map_t const& state_map);

void gen_javascript(std::string const& package_name, std::string const& fsmclass, state_map_list_t const& state_map_list, std::string const& start_map, std::string const& start_state, transition_set_t const& transition_set, std::string const& class_name)
{
    intented_out out(cout, 0);

    // https://github.com/stevekwan/experiments/blob/master/javascript/module-pattern.html
    out << "// -*- tab-width: 4; -*-\n";
    out << "// -*- coding: utf-8 -*-\n";
    out << "\n";
    out << "//\n";
    out << "// This file is automatically generated by State Machine Generator.\n";
    out << "//\n";
    out << "\n";
    out << "var " << package_name << " = " << package_name << " || {};\n";
    out << "" << package_name << "." << fsmclass << " = function(ctxt) {\n";
    out << "    var currentState, previousState, debugMode = false;\n";
    out << "    var setState = function(state) { currentState = state; if (debugMode) { console.log('ENTER STATE: %s', state.getName()); } };\n";

    for (auto&& state_map : state_map_list) {
        generate_state_map(state_map);
    }

    out << "    currentState = " << start_map << "." << start_state << ";\n";
    out << "    var defaultState = " << start_map << ".Default || {};\n";
    out << "    var dispatch = function(actionName) {\n";
    out << "        return function() {\n";
    out << "            var fn = currentState[actionName] || defaultState[actionName] || defaultState.Default;\n";
    out << "            return fn.apply(this, arguments);\n";
    out << "        };\n";
    out << "    };\n";
    out << "    return {\n";
    out << "        enterStartState: function() { currentState.Entry(); },\n";
    out << "        getPreviousState: function() { return previousState; },\n";
    out << "        getState: function() { return currentState; },\n";
    out << "        isDebugMode: function() { return debugMode; },\n";
    out << "        setDebugMode: function(mode) { debugMode = mode; }";

    for (auto const& transition_name : transition_set) {
        if (transition_name != "Default") {
            out << ",\n";
            out << "        " << transition_name << ": dispatch('" << transition_name << "')";
        }
    }

    out << "\n";
    out << "    };\n";

    out << "};" << endl;
}

static void generate_state_map(state_map_t const& state_map)
{

    string const& state_map_name = state_map.get_state_map_name();
    state_list_t const& state_list = state_map.get_state_list();

    // カスタムアクションの出力とステート遷移の出力
    auto generate_transition = [&](transition_t const& transition, int indent)
    {
        intented_out out(cout, indent);

        // 遷移先のステートがある場合には Exit() を出力する。
        if ( !transition.get_next_state().empty()) {
            out << "currentState.Exit();\n";
        }

        // 現在のステートをNULLにセットする。
        out << "previousState = currentState;\n";

        // カスタムアクションを出力する。
        if ( !transition.get_action_list().empty()) {
            out << "currentState = null;\n";
            out << "try {" << "\n";
            out << "    // Custom action" << "\n";
        }

        for (auto const& action : transition.get_action_list()) {
            out << "    ctxt." << action.func() << ";\n";
        }

        // 次の遷移先への移動をfinally区の中に入れるかどうか
        int next_state_indent = 0;

        if ( !transition.get_action_list().empty()) {
            out << "} finally {" << "\n";
            next_state_indent++;
        }

        // 遷移先のステートがある場合には Entry() を出力する。
        if (transition.get_next_state().empty()) {
             out(next_state_indent) << "currentState = previousState;\n";
        }
        else {
             out(next_state_indent) << "setState(" << state_map_name << "." << transition.get_next_state() << ");\n";
             out(next_state_indent) << "currentState.Entry();\n";
        }

        if ( !transition.get_action_list().empty()) {
            out << "}" << "\n";
        }
    };

    intented_out out(cout, 0);
    bool need_comma = false;
    out(1) << "var " << state_map_name << " = {\n";
    for (auto const& state : state_list) {
        if (need_comma) cout << ",\n";

        out(2) << state.get_state_name() << ": {\n";
        out(3) << "getName : function() { return \"" << state.get_state_name() << "\"; },\n";
        out(3) << "Entry : function() {\n";

        for (auto&& action : state.get_entry()) {
             out(4) << "ctxt." << action.func() << ";\n";
        }
        out(3) << "},\n";
        out(3) << "Exit : function() {\n";
             ;
        for (auto const& action : state.get_exit()) {
             out(4) << "ctxt." << action.func() << ";\n";
        }
        out(3) << "}";

        for (auto const& transition_name_list_pair : state.get_transitions()) {
            string const& transition_name = transition_name_list_pair.first;

            cout << ",\n";
            out(3) << transition_name << ": function(";
            bool first_parameter_seen = false;
            for (auto&& parameter : transition_name_list_pair.second.at(0).get_parameter_list()) {
                if (first_parameter_seen)
                    cout << ", ";
                cout << parameter.get_name();
                first_parameter_seen = true;
            }
            cout << ") {\n";

            bool else_block = false;
            for (auto&& transition : transition_name_list_pair.second) {
                if ( !transition.get_guard().empty()) {
                    out(4) << (else_block ? "else if" : "if") << " (" << transition.get_guard() << ") {\n";

                    generate_transition(transition, out.get_indent() + 5);

                    out(4) << "}\n";
                    else_block = true;
                }
                else {
                    if (else_block) {
                        out(4) << "else {\n";
                    }

                    generate_transition(transition, out.get_indent() + (else_block ? 5 : 4));

                    if (else_block) {
                        out(4) << "}\n";
                    }
                }
            }

            out(3) << "}";
        }

        cout << "\n";
        out(2) << "}";
        need_comma = true;
    }
    cout << "\n"
         << "    " << "};" << endl;

}
