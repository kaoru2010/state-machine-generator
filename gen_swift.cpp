#include <iostream>
#include <string>
#include "smc_compiler.h"
#include "gen.h"


using namespace std;

template <typename T>
typename T::mapped_type get(T const& map, typename T::key_type const& key)
{
    typename T::const_iterator iter(map.find(key));
    return iter != map.end() ? iter->second : typename T::mapped_type();
}

static void generate_state_map(state_map_t const& state_map, std::string const& package_name, std::string const& fsmclass, std::string const& class_name, std::map<string, string> const& action_map, transition_set_t const& transition_set, std::map<std::string, parameter_list_t> const& transition_params);

string declare_param(std::map<std::string, parameter_list_t> const& transition_params, std::string const transition_name) {
    parameter_list_t plist = get(transition_params, transition_name);
    string params = "";
    for (auto& param : plist) {
        if (params != "") {
            params += ", ";
        }
        params += param.get_name() + ":" + param.get_type();
    }
    return params;
}

string call_param(std::map<std::string, parameter_list_t> const& transition_params, std::string const transition_name) {
    parameter_list_t plist = get(transition_params, transition_name);
    string call_params = "";
    for (auto& param : plist) {
        call_params += ", " + param.get_name() + ": " + param.get_name();
    }
    return call_params;
}

void gen_swift(
    std::string const& package_name,
    std::string const& fsmclass,
    state_map_list_t const& state_map_list,
    std::string const& start_map,
    std::string const& start_state,
    transition_set_t const& transition_set,
    std::string const& class_name,
    std::map<std::string, std::string> const& action_map,
    std::vector<std::string> const& include_list,
    std::vector<std::string> const& import_list,
    std::map<std::string, parameter_list_t> const& transition_params)
{
    string full_fsm_name = package_name + "_" + fsmclass;

    cout << "// -*- tab-width: 4; -*-\n";
    cout << "// -*- coding: utf-8 -*-\n";
    cout << "\n";
    cout << "//\n";
    cout << "// This file is automatically generated by State Machine Generator.\n";
    cout << "//\n";
    cout << "\n";

    cout << "import Foundation\n";

    for (auto&& include : include_list) {
        cout << "// #include <" << include << ">\n";
    }

    for (auto&& import: import_list) {
        cout << "import " << import << "\n";
    }
    cout << "\n";

//    cout << "public protocol " << package_name << "_Action {\n";
//    for (auto const& action : action_map) {
//        cout << "    func " << action.second << "\n";
//    }
//    cout << "}\n\n";

//    cout << "/*\n";
//    cout << "public class " << class_name << " : " << package_name << "_Action {\n";
//    for (auto const& action : action_map) {
//        cout << "    public func " << action.second << " {}\n";
//    }
//    cout << "}\n";
//    cout << "*/\n";

    cout
        << "\n"
        << "public class " << full_fsm_name << " {\n"
        << "\n"
        << "    private var currentState : " << package_name << "_" << start_map << "_State?\n"
        << "    private var previousState : " << package_name << "_" << start_map << "_State?\n"
        << "    public var debugMode = false\n"
        << "    weak var ctxt : " << class_name << "?\n"
        << "\n"
        << "    public init(context: " << class_name << ") {\n"
        << "        self.currentState = " << package_name << "_" << start_map << "._" << start_state << "\n"
        << "        self.ctxt = context\n"
        << "    }\n"
        << "\n"
        << "    public func enterStartState() {\n"
        << "        if let context = ctxt {\n"
        << "            currentState!.Entry(self, ctxt: context)\n"
        << "        }\n"
        << "    }\n"
        << "\n"
        << "    private func setState(state:" << package_name << "_" << start_map << "_State) {\n"
        << "        currentState = state;\n"
        << "        if (debugMode) {\n"
        << "            NSLog(\"ENTER STATE: %s\", state.getName())\n"
        << "        }\n"
        << "    }\n"
        ;


    for (auto&& transition_name : transition_set) {
        std::string params = declare_param(transition_params, transition_name);
        std::string call_params = call_param(transition_params, transition_name);

        cout << "\n";
        cout << "    public func " << transition_name << "(" << params << ") {\n";
        cout << "        if let context = ctxt {\n";
        cout << "            currentState!." << transition_name << "(self, ctxt: context" << call_params << ")\n";
        cout << "        }\n";
        cout << "    }\n";
    }

    cout << "\n";
    cout << "}\n";
    cout << "\n";
    cout << "\n";
    cout << "\n";

    for (auto&& state_map : state_map_list) {
        generate_state_map(state_map, package_name, fsmclass, class_name, action_map, transition_set, transition_params);
    }
}


static void generate_state_map(state_map_t const& state_map, std::string const& package_name, std::string const& fsmclass, std::string const& class_name, std::map<string, string> const& action_map, transition_set_t const& transition_set, std::map<std::string, parameter_list_t> const& transition_params)
{
    string full_fsm_name = package_name + "_" + fsmclass;

    string const& state_map_name = package_name + "_" + state_map.get_state_map_name();
    state_list_t const& state_list = state_map.get_state_list();

    // カスタムアクションの出力とステート遷移の出力
    auto generate_transition = [&](transition_t const& transition, int indent)
    {
        intented_out out(cout, indent);

        // 遷移先のステートがある場合には Exit() を出力する。
        if ( !transition.get_next_state().empty()) {
            out << "fsm.currentState!.Exit(fsm, ctxt: ctxt)\n";
        }

        // 現在のステートをNULLにセットする。
        out << "fsm.previousState = fsm.currentState\n";

        // カスタムアクションを出力する。
        if ( !transition.get_action_list().empty()) {
            out << "fsm.currentState = nil\n";
            out << "//try {" << "\n";
            out << "// Custom action" << "\n";
        }

        for (auto const& action : transition.get_action_list()) {
            out << "ctxt." << action.func() << "\n";
        }

        // 次の遷移先への移動をfinally区の中に入れるかどうか
        int next_state_indent = 0;

        if ( !transition.get_action_list().empty()) {
            out << "//} finally {" << "\n";
            //next_state_indent++;
        }

        // 遷移先のステートがある場合には Entry() を出力する。
        if (transition.get_next_state().empty()) {
             out(next_state_indent) << "fsm.currentState = fsm.previousState\n";
        }
        else {
             out(next_state_indent) << "fsm.setState(" << state_map_name << "._" << transition.get_next_state() << ")\n";
             out(next_state_indent) << "fsm.currentState!.Entry(fsm, ctxt: ctxt)\n";
        }

        if ( !transition.get_action_list().empty()) {
            out << "//}" << "\n";
        }
    };

    const string state_map_protocol_name = state_map_name + "_State";
    cout << "private protocol " << state_map_protocol_name << " {\n";
    cout << "    func getName() -> String\n";
    cout << "    func Entry(fsm:" << full_fsm_name << ", ctxt:" << class_name << ")\n";
    cout << "    func Exit(fsm:" << full_fsm_name << ", ctxt:" << class_name << ")\n";
    cout << "    func Default(fsm:" << full_fsm_name << ", ctxt:" << class_name << ")\n";
    for (auto&& transition_name : transition_set) {
        if (transition_name != "Default") {
            string params = declare_param(transition_params, transition_name);
            if (params != "") { params = ", " + params; }
            cout << "    func " << transition_name << "(fsm:" << full_fsm_name << ", ctxt:" << class_name << params << ")\n";
        }
    }
    cout << "}\n";

    intented_out out(cout, 0);
    bool need_comma = false;
    out << "let " << state_map_name << " = _" << state_map_name << "()\n";
    cout << "\n";
    out << "public class _" << state_map_name << " {\n";
    for (auto const& state : state_list) {
        cout << "    let _" << state.get_state_name() << " = " << state.get_state_name() << "()\n";
    }

    cout << "\n";
    const string base_state_impl_name = state_map_name + "_StateImpl";

    out(1) << "public class " << base_state_impl_name << " : " << state_map_protocol_name << " {\n";
    out(2) << "func getName() -> String { return \"\" }\n";
    out(2) << "func Entry(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") {}\n";
    out(2) << "func Exit(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") {}\n";
    out(2) << "func Default(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") { abort() }\n";
    for (auto&& transition_name : transition_set) {
        if (transition_name != "Default") {
            string params = declare_param(transition_params, transition_name);
            string calls = call_param(transition_params, transition_name);
            if (params != "") { params = ", " + params; }
            out(2) << "func " << transition_name << "(fsm:" << full_fsm_name << ", ctxt:" << class_name << params << ") {\n";
            out(3) << "Default(fsm, ctxt: ctxt)\n";
            out(2) << "}\n";
        }
    }
    out(1) << "}\n";

    bool default_state_present = false;

    for (auto const& state : state_list) {
        bool default_state = state.get_state_name() == "Default";
        const string func_decl = "override public func ";
        if (default_state)
            default_state_present = true;

        cout << "\n";
        out(1) << "public class " << state.get_state_name() << " : "<< (default_state ? base_state_impl_name : "Default") << " {\n";
        out(2) << func_decl << "getName() -> String { return \"" << state.get_state_name() << "\" }\n\n";
        out(2) << func_decl << "Entry(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") {\n";

        for (auto&& action : state.get_entry()) {
             out(3) << "ctxt." << action.func() << "\n";
        }
        out(2) << "}\n";
        cout << "\n";
        out(2) << func_decl << "Exit(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") {\n";
        for (auto const& action : state.get_exit()) {
             out(3) << "ctxt." << action.func() << "\n";
        }
        out(2) << "}\n";

        for (auto const& transition_name_list_pair : state.get_transitions()) {
            string const& transition_name = transition_name_list_pair.first;

            cout << "\n";
            out(2) << func_decl << transition_name << "(fsm:" << full_fsm_name << ", ctxt:" << class_name;
            for (auto&& parameter : transition_name_list_pair.second.at(0).get_parameter_list()) {
                cout << ", " << parameter.get_name() << ":" << parameter.get_type();
            }
            cout << ") {\n";

            bool else_block = false;
            for (auto&& transition : transition_name_list_pair.second) {
                if ( !transition.get_guard().empty()) {
                    out(3) << (else_block ? "else if" : "if") << " (" << transition.get_guard() << ") {\n";

                    generate_transition(transition, 5);

                    out(3) << "}\n";
                    else_block = true;
                }
                else {
                    if (else_block) {
                        out(3) << "else {\n";
                    }

                    generate_transition(transition, else_block ? 4 : 3);

                    if (else_block) {
                        out(3) << "}\n";
                    }
                }
            }

            out(2) << "}\n";
        }

        cout << "\n";
        out(1) << "}\n"
             ;
        need_comma = true;
    }

    if ( !default_state_present) {
        cout << "\n";
        out(1) << "public class Default : " << state_map_name << "_State {\n";
        out(2) << "public func getName() -> String { return \"DefaultState\" }\n\n";
        out(2) << "public func Entry(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") {}\n";
        out(2) << "public func Exit(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") {}\n";

        for (auto&& transition_name : transition_set) {
             out(2) << "public func " << transition_name << "(fsm:" << full_fsm_name << ", ctxt:" << class_name << ") {}\n";
        }
        out(1) << "}\n";
    }

    cout << "}" << endl;

}
